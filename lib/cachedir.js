var fs = require('fs');
var log = require('sslog');
var path = require('path');
var request = require('request');
var crypto = require('crypto');
var mkdirp = require('mkdirp');
var sprintf = require('util').format;

/**
 * Util function used to generate cache filenames.
 */
function md5(str, callback) {
  if (typeof callback !== 'function') callback = function() {};
  callback(crypto.createHash('md5').update(str).digest('hex'));
}

/**
 * Util function that uniquely-enough tags a filename to avoid collisions inside the working dir
 * both intra- and cross-process. We do so by appending the following suffix to the input string:
 * ".{pid}.{in-process-rolling-counter}"
 */
var MAX_INT = (2 << 53) - 1;
var counter = 0;
function tag(str) {
  var result = str + '.' + process.pid + '.' + ++counter;
  counter %= MAX_INT;
  return result;
}
/**
 * And its dual, untagging a string generated by tag().
 */
function untag(str) {
  var parts = str.split('.');
  parts.pop(); // Discard counter
  parts.pop(); // Discard pid
  return parts.join();
}

/**
 * Constructs a Cachedir instance that refers to a cache directory tree where downloaded raw image
 * assets as well as transformed assets are stored, as well as a working directory where in-flight
 * downloads and transforms stage their work until successful completion.
 */
var Cachedir = function(config) {
  config = config || {};
  this.cache_dir = config.cache_dir;
  this.work_dir = config.work_dir;
};

Cachedir.prototype.ensure_path = function(filename, callback) {
  mkdirp(path.dirname(filename), callback);
};

/**
 * Generates a cache path from filename string.
 * The path is generated using the first 4 characters of the filename.
 * E.g.: this_is_a_filename.txt will become - <cache_dir>/t/h/i/s/this_is_a_filename.txt
 *   where cache_dir, is the configured dir for caches.
 *
 * The callback has 2 params:
 *   string  - full path for the cached file
 *   boolean - if the cached file already exists or not
 */
Cachedir.prototype.get_cached_path = function(filename, callback) {
  var file = path.basename(filename);
  var dir = file.substr(0, 4).split('').join('/'); // This builds the single-char dir tree.
  var dest = sprintf('%s/%s/%s', this.cache_dir, dir, file);

  fs.exists(dest, function(exists) {
    callback(dest, exists);
  });
};

/**
 * Generates a working path from filename string.
 * The callback has 2 params:
 *   string  - full path for the working file
 *   boolean - if the working file already exists or not
 */
Cachedir.prototype.get_working_path = function(filename, callback) {
  var workingFile = tag(path.basename(filename));
  var dest = sprintf('%s/%s', this.work_dir, workingFile);

  fs.exists(dest, function(exists) {
    if (exists) {
      log.warn('Working file already exists: ' + dest);
    }
    callback(dest, exists);
  })
};

/**
 * Atomically promote a file in our working directory space into the stable cache directory tree.
 * The callback has 2 params:
 *   error  - for any fs failure
 *   string - promoted cache file path on success
 */
Cachedir.prototype.promote_working_path_to_cache = function(workingPath, callback) {
  var workingFile = untag(path.basename(workingPath));
  console.log('UNTAGGED', workingFile, workingPath);
  this.get_cached_path(workingFile, function(dest, exists) {
    if (exists) {
      log.warn('Renaming working file over existing cache file: ' + dest);
    }
    // We need full target dir path in place before our atomic rename.
    mkdirp(path.dirname(dest), function(err) {
      if (err) {
        callback(err);
        return;
      }
      // Atomically replace cache file with working file.
      fs.rename(workingPath, dest, function(err) {
        if (err) {
          callback(err);
          return;
        }
        callback(null, dest);
      });
    });
  });
}

/**
 * Downloads a file from given url and saves it in cache dir; the working directory is used for in-flight download
 * and upon success the result is atomically moved into the stable cache dir tree. If a locally cached file already
 * exists, no download is done unless force=true in which case any existing cache file is overwritten if the
 * forced download succeeds.
 *
 * The cache file name is based on the md5 of the url.
 *
 * The callback has 2 params:
 *   error  - for any fs failure
 *   string - full path for the cache file
 */
Cachedir.prototype.download = function(url, force, callback) {
  var self = this;

  // make sure we have a proper callback passed
  if (typeof callback !== 'function') {
    callback = force;
    force = false;
  }

  md5(url, function(hash) {
    self.get_cached_path(hash, function(output_file, exists) {
      if (exists && !force) {
        log.verbose('Already downloaded. file=' + output_file);
        callback(null, output_file);
      } else {

        // Helper function to avoid duplicate callback invocations.
        var done = false;
        function finish(err, outputFile) {
          if (!done) {
            done = true;
            callback(err, outputFile);
          } else {
            log.warn('Download finish invoked multiple times. err=' + err + ', file=' + outputFile);
          }
        }

        self.get_working_path(hash, function(workingPath, workingExists) {
          // Ensure full working dir path exists.
          self.ensure_path(workingPath, function(err) {
            if (err) {
              finish(err);
              return;
            }

            // Download target URL to working space and upon success, move it into cache dir tree.
            var writer = fs.createWriteStream(workingPath);
            writer.on('open', function (fd) {
              // Start download into target working file.
              var r = request(url);
              r.on('error', finish);
              r.on('response', function (res) {
                log.info('Download status code=' + res.statusCode + ', file=' + workingPath);
                if (res.statusCode !== 200) {
                  finish(new Error('Download failed. url=' + url + ', status code=' + res.statusCode));
                  return;
                }
                // Pipe response body through to target working file.
                r.pipe(writer);
              });
              writer.on('close', function () {
                log.info('Done writing to file: ' + workingPath);

                // TODO: consider validating download file here? However, any errors result is this file being discarded.
                self.promote_working_path_to_cache(workingPath, callback);

              });
              writer.on('error', function (err) {
                log.warn('Error piping download to file. err=' + err + ', file=' + outputFile);
                finish(err);
              })
            });

          });
        });

      }
    });
  });
};

exports.create = function(config) {
  return new Cachedir(config);
};
